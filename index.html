<!doctype html>
<head>
<meta charset="UTF-8">
<meta name="referrer" content="never">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<base target="_blank">
<title>ArchiveBot dashboard 2.0</title>
</head>
<body>
<style>
html, body {
	background-color: #D0C0AE;
	font-family: Tahoma, Arial, sans-serif;
	font-size: 13px;
}

.padded-page {
	padding: 20px 27px 20px 27px;
}

.header {
	font-family: Arial, sans-serif;
	font-weight: bold;
	font-size: 18px;
	margin: 0 0 20px 0;
}

.job-header {
	display: flex;
	align-items: flex-end;
	justify-content: space-between;
	flex-flow: row nowrap;
}

.job-url {
	font-family: Arial, sans-serif;
	font-size: 14px;
	font-weight: bold;
	text-decoration: none;
}

.job-ident {
	margin: 0 1px 0 0;
	border: 0;
	background-color: #D0C0AE;
	color: #786552;
	font-weight: bold;
	text-align: right;
}

.log-window {
	background-color: #FFF7E1;
	overflow-y: scroll;
	height: 192px;
	border: 1px solid #999;
	margin: 0 0 1em 0;
	border-radius: 3px;
}

.log-window-stopped {
	border: 1px solid #222;
	box-shadow: 2px 2px 4px #888;

}

.line-normal {
	white-space: pre;
	width: 100%;
}

.line-error {
	white-space: pre;
	width: 100%;
	background-color: #FFB9B9;
}

.line-warning {
	white-space: pre;
	width: 100%;
	background-color: #F7DB7D;
}

.line-redirect {
	white-space: pre;
	width: 100%;
	background-color: #E7CEEA;
}

.line-stdout {
	white-space: pre;
	width: 100%;
	background-color: #DCD8CB;
}

a {
	color: #000;
	text-decoration: none;
}

.underlined-a {
	text-decoration: underline;
}
</style>
<div class="padded-page">
	<div class="header">
		<a href="http://archiveteam.org/index.php?title=ArchiveBot" class="underlined-a">ArchiveBot</a>
		tracking ~<span id="num-crawls">0</span> crawls.<br>
	</div>

	<div id="critical-info">
		<noscript>
			Need JavaScript and ES5 and WebSocket -&gt; TCP:4567
		</noscript>
	</div>
	<div id="traffic"></div>
	<div id="logs"></div>
</div>
<script>
"use strict";

var assert = function(condition, message) {
	if(!condition) {
		throw message || "Assertion failed";
	}
};

var byId = function(id) {
	return document.getElementById(id);
};

var text = function(s) {
	return document.createTextNode(s);
};

/**
 * appendChild but accepts strings and arrays of children|strings
 */
var appendAny = function(e, thing) {
	if(Array.isArray(thing)) {
		for(var i=0; i < thing.length; i++) {
			appendAny(e, thing[i]);
		}
	} else if(typeof thing == "string") {
		e.appendChild(text(thing));
	} else {
		// TODO: Check that it's actually a DOM node first
		e.appendChild(thing);
	}
};

/**
 * Create DOM element with attributes and children from Array<node|string>|node|string
 */
var h = function(elem, attrs, thing) {
	var e = document.createElement(elem);
	if(attrs != null) {
		for(var attr in attrs) {
			if(attr == "spellcheck" || attr == "readonly") {
				e.setAttribute(attr, attrs[attr]);
			} else {
				e[attr] = attrs[attr];
			}
		}
	}
	if(thing != null) {
		appendAny(e, thing);
	}
	return e;
};

var href = function(href, text) {
	var a = h("a");
	a.href = href;
	a.textContent = text;
	return a;
};

var prettyJson = function(obj) {
	return JSON.stringify(obj, undefined, 2);
};

// Copied from Coreweb/js_coreweb/cw/string.js
/**
 * Like Python's s.split(delim, num) and s.split(delim)
 * This does *NOT* implement Python's no-argument s.split()
 *
 * @param {string} s The string to split.
 * @param {string} sep The separator to split by.
 * @param {number} maxsplit Maximum number of times to split.
 *
 * @return {!Array.<string>} The splitted string, as an array.
 */
var split = function(s, sep, maxsplit) {
	assert(typeof sep == "string",
		"arguments[1] of split must be a separator string");
	if(maxsplit === undefined || maxsplit < 0) {
		return s.split(sep);
	}
	var pieces = s.split(sep);
	var head = pieces.splice(0, maxsplit);
	// after the splice, pieces is shorter and no longer has the `head` elements.
	if(pieces.length > 0) {
		var tail = pieces.join(sep);
		head.push(tail); // no longer just the head.
	}
	return head;
};

/**
 * [[1, 2], [3, 4]] -> {1: 2, 3: 4}
 */
var intoObject = function(arr) {
	var obj = {};
	arr.forEach(function(e) {
		obj[e[0]] = e[1];
	});
	return obj;
};

var getQueryArgs = function() {
	var pairs = location.search.replace("?", "").split("&");
	if(pairs == "") {
		return {};
	}
	return intoObject(pairs.map(function(e) { return split(e, "=", 1); }));
};

var isSafari = navigator.userAgent.indexOf("Safari") != -1;

/*** End of utility code ***/



var JobsTracker = function() {
	this.known = {};
	this.sorted = [];
};

JobsTracker.prototype.resort = function() {
	this.sorted.sort(function(a, b) { return a["started_at"] > b["started_at"] ? -1 : 1 });
}

/**
 * Returns true if a new job was added
 */
JobsTracker.prototype.handleJobData = function(jobData) {
	var ident = jobData["ident"];
	var alreadyKnown = ident in this.known;
	if(!alreadyKnown) {
		this.known[ident] = true;
		this.sorted.push(jobData);
		this.resort();
	}
	return !alreadyKnown;
};



var JobRenderInfo = function(logWindow, logSegment, lineCountWindow, lineCountSegment) {
	this.logWindow = logWindow;
	this.logSegment = logSegment;
	this.lineCountWindow = lineCountWindow;
	this.lineCountSegment = lineCountSegment;
};



var Reusable = {
	obj_className_line_normal: {"className": "line-normal"},
	obj_className_line_error: {"className": "line-error"},
	obj_className_line_warning: {"className": "line-warning"},
	obj_className_line_redirect: {"className": "line-redirect"},
	obj_className_line_stdout: {"className": "line-stdout"}
};



var JobsRenderer = function(container, historyLines) {
	this.container = container;
	this.historyLines = historyLines;
	this.linesPerSegment = Math.max(1, Math.round(this.historyLines / 10));
	this.jobs = new JobsTracker();
	// ident -> JobRenderInfo
	this.renderInfo = {};
	this.mouseInside = null;
};

JobsRenderer.prototype._getNextJobInSorted = function(ident) {
	for(var i=0; i < this.jobs.sorted.length; i++) {
		var e = this.jobs.sorted[i];
		if(e["ident"] == ident) {
			return this.jobs.sorted[i+1];
		}
	}
	return null;
};

JobsRenderer.prototype._createLogSegment = function() {
	return h('div');
};

JobsRenderer.prototype._createLogContainer = function(jobData) {
	var ident = jobData["ident"];
	var beforeJob = this._getNextJobInSorted(ident);
	var beforeElement = beforeJob == null ? null : byId("log-container-" + beforeJob["ident"]);

	var logSegment = this._createLogSegment();

	var logWindowAttrs = {
		"className": "log-window",
		"id": "log-window-" + ident,
		"onmouseenter": function(ev) {
			this.mouseInside = ident;
			ev.target.classList.add('log-window-stopped');
		}.bind(this),
		"onmouseleave": function(ev) {
			this.mouseInside = null;
			ev.target.classList.remove('log-window-stopped');
		}.bind(this)
	}

	// If you reach the end of a log window, the browser annoyingly
	// starts to scroll the page instead.  We prevent this behavior here.
	// If the user wants to scroll the page, they need to move their
	// mouse outside a log window first.
	if(!isSafari) {
		logWindowAttrs["onwheel"] = function(ev) {
			// Note: offsetHeight is "wrong" by 2px but it doesn't matter
			//console.log(ev, logWindow.scrollTop, (logWindow.scrollHeight - logWindow.offsetHeight));
			if(ev.deltaY < 0 && logWindow.scrollTop == 0) {
				ev.preventDefault();
			} else if(ev.deltaY > 0 && logWindow.scrollTop >= (logWindow.scrollHeight - logWindow.offsetHeight)) {
				ev.preventDefault();
			}
		}
	} else {
		// Safari 7.0.5 can't preventDefault or stopPropagation an onwheel event,
		// so use onmousewheel instead.
		logWindowAttrs["onmousewheel"] = function(ev) {
			//console.log(ev, logWindow.scrollTop, (logWindow.scrollHeight - logWindow.offsetHeight));
			if(ev.wheelDeltaY > 0 && logWindow.scrollTop == 0) {
				ev.preventDefault();
			} else if(ev.wheelDeltaY < 0 && logWindow.scrollTop >= (logWindow.scrollHeight - logWindow.offsetHeight)) {
				ev.preventDefault();
			}
		}
	}

	var logWindow = h('div', logWindowAttrs, logSegment);
	var div = h(
		'div',
		{"id": "log-container-" + ident}, [
			h("div", {"className": "job-header"}, [
				h("a", {"className": "job-url", "href": jobData["url"]}, jobData["url"]),
				h("input", {
					"className": "job-ident",
					"type": "text",
					"value": ident,
					"size": "28",
					"spellcheck": "false",
					"readonly": "",
					"onclick": function() { this.select(); }
				})
			]),
			logWindow
		]
	);
	this.renderInfo[ident] = new JobRenderInfo(logWindow, logSegment, 0, 0);
	this.container.insertBefore(div, beforeElement);
}

JobsRenderer.prototype._renderDownloadLine = function(data, logSegment) {
	if(data["is_warning"]) {
		var attrs = Reusable.obj_className_line_warning;
	} else if(data["is_error"]) {
		var attrs = Reusable.obj_className_line_error;
	} else if(data["response_code"] && data["response_code"] >= 300 && data["response_code"] < 400) {
		var attrs = Reusable.obj_className_line_redirect;
	} else {
		var attrs = Reusable.obj_className_line_normal;
	}
	logSegment.appendChild(h("div", attrs, [
		" " + data["response_code"] + " " + data["wget_code"] + " ",
		href(data["url"], data["url"])
	]));
	return 1;
};

JobsRenderer.prototype._renderStdoutLine = function(data, logSegment) {
	var cleanedMessage = data["message"].replace(/[\r\n]+$/, "").replace(/ \\u2018/g, ' \u2018').replace(/\\u2019 /g, '\u2019 ');
	var renderedLines = 0;
	if(!cleanedMessage) {
		return renderedLines;
	}
	var lines = cleanedMessage.split("\n");
	for(var i=0; i < lines.length; i++) {
		var line = lines[i];
		if(!line) {
			continue;
		}
		logSegment.appendChild(h("div", Reusable.obj_className_line_stdout, " " + line));
		renderedLines += 1;
	}
	return renderedLines;
};

JobsRenderer.prototype.handleData = function(data) {
	var added = this.jobs.handleJobData(data["job_data"]);
	if(added) {
		this._createLogContainer(data["job_data"]);
		byId('num-crawls').textContent = this.jobs.sorted.length;
	}
	var type = data["type"];
	if(!(type == "download" || type == "stdout")) {
		return;
	}

	var ident = data["job_data"]["ident"];

	var info = this.renderInfo[ident];
	if(!info) {
		console.warn("No render info for " + ident);
		return;
	}

	if(type == "download") {
		var linesRendered = this._renderDownloadLine(data, info.logSegment);
	} else if(type == "stdout") {
		var linesRendered = this._renderStdoutLine(data, info.logSegment);
	} else {
		assert(false, "line should not be reached");
	}

	if(!linesRendered) {
		return;
	}

	info.lineCountWindow += linesRendered;
	info.lineCountSegment += linesRendered;

	if(info.lineCountSegment >= this.linesPerSegment) {
		//console.log("Created new segment", info);
		var newSegment = this._createLogSegment();
		info.logWindow.appendChild(newSegment);
		info.logSegment = newSegment;
		info.lineCountSegment = 0;
	}

	if(this.mouseInside != ident) {
		// We may have to remove more than one segment, if the user
		// has paused the log window for a while.
		while(info.lineCountWindow >= this.historyLines + this.linesPerSegment) {
			info.logWindow.removeChild(info.logWindow.firstChild);
			info.lineCountWindow -= this.linesPerSegment;
		}

		// Scroll to the bottom
		info.logWindow.scrollTop = info.logWindow.scrollHeight;
	}
};



var BatchingQueue = function(callable, minInterval) {
	this.callable = callable;
	this._minInterval = minInterval;
	this.queue = [];
	this._timeout = null;
	this._boundRunCallable = this._runCallable.bind(this);
};

BatchingQueue.prototype.setMinInterval = function(minInterval) {
	this._minInterval = minInterval;
};

BatchingQueue.prototype._runCallable = function() {
	this._timeout = null;
	var queue = this.queue;
	this.queue = [];
	this.callable(queue);
};

BatchingQueue.prototype.callNow = function() {
	if(this._timeout !== null) {
		clearTimeout(this._timeout);
		this._timeout = null;
	}
	this._runCallable();
};

BatchingQueue.prototype.push = function(v) {
	this.queue.push(v);
	if(this._timeout === null) {
		this._timeout = setTimeout(this._boundRunCallable, this._minInterval);
	}
};



var Decayer = function(initial, multiplier, max) {
	this.initial = initial;
	this.multiplier = multiplier;
	this.max = max;
	this.reset();
};

Decayer.prototype.reset = function() {
	// First call to .decay() will multiply, but we want to get the `intitial`
	// value on the first call to .decay(), so divide.
	this.current = this.initial / this.multiplier;
	return this.current;
};

Decayer.prototype.decay = function() {
	this.current = Math.min(this.current * this.multiplier, this.max);
	return this.current;
};



var Dashboard = function() {
	this.messageCount = 0;

	var args = getQueryArgs();

	var historyLines = args["historyLines"] ? Number(args["historyLines"]) : 1000;
	this.dumpTraffic = args["dumpMax"] && Number(args["dumpMax"]) > 0;
	if(this.dumpTraffic) {
		this.dumpMax = Number(args["dumpMax"]);
	}
	this.jobsRenderer = new JobsRenderer(byId('logs'), historyLines);

	var batchTimeWhenHidden = 5000;
	var batchTimeWhenVisible = 125;

	var xhr = new XMLHttpRequest();
	xhr.onload = function() {
		var recentLines = JSON.parse(xhr.responseText);
		for(var i=0; i < recentLines.length; i++) {
			this.handleData(recentLines[i]);
		}

		this.queue = new BatchingQueue(function(queue) {
			//console.log("Queue has ", queue.length, "items");
			for(var i=0; i < queue.length; i++) {
				this.handleData(JSON.parse(queue[i]));
			}
		}.bind(this), batchTimeWhenVisible);

		this.decayer = new Decayer(1000, 1.5, 60000);
		this.connectWebSocket();

		document.addEventListener("visibilitychange", function() {
			if(document.hidden) {
				//console.log("Page has become hidden");
				this.queue.setMinInterval(batchTimeWhenHidden);
			} else {
				//console.log("Page has become visible");
				this.queue.setMinInterval(batchTimeWhenVisible);
				this.queue.callNow();
			}
		}.bind(this), false);
	}.bind(this);
	xhr.open("GET", "http://arshboard.at.ninjawedding.org:4567/logs/recent");
	xhr.send("");
};

Dashboard.prototype.handleData = function(data) {
	this.messageCount += 1;
	if(this.dumpTraffic && this.messageCount <= this.dumpMax) {
		byId('traffic').appendChild(h("pre", null, prettyJson(data)));
	}
	this.jobsRenderer.handleData(data);
};

Dashboard.prototype.connectWebSocket = function() {
	this.ws = new WebSocket("ws://arshboard.at.ninjawedding.org:4567/stream");

	this.ws.onmessage = function(ev) {
		this.queue.push(ev["data"]);
	}.bind(this);

	this.ws.onopen = function(ev) {
		console.log("WebSocket opened:", ev);
		this.decayer.reset();
	}.bind(this);

	this.ws.onclose = function(ev) {
		console.log("WebSocket closed:", ev);
		var delay = this.decayer.decay();
		console.log("Reconnecting in", delay, "ms");
		setTimeout(this.connectWebSocket.bind(this), delay);
	}.bind(this);
};

var ds = new Dashboard();

</script>
</body>
</html>
